"""
WAF Stressor - WAF Detection and Analysis
Production-ready analysis suite for WAF fingerprinting, metrics calculation, and finding generation

Â© GHOSTSHINOBI 2025
"""

import re
import statistics
from typing import Tuple, Dict, List, Optional, Any
from collections import defaultdict

from core import (
    ResponseSignature, TestResult, BaselineSnapshot, TestMetrics,
    VariantType, HTTPMethod, Finding, SeverityLevel, VulnerabilityType
)


class WAFDetector:
    """
    Production-grade WAF detection and fingerprinting
    Supports 15+ WAF vendors with multi-signal analysis
    """

    # Comprehensive WAF signature database
    WAF_SIGNATURES = {
        'cloudflare': {
            'headers': ['cf-ray', 'cf-cache-status', '__cfduid', 'cf-request-id'],
            'server_patterns': [r'cloudflare', r'cloudflare-nginx'],
            'body_patterns': [r'cloudflare', r'ray id:?\s*[\da-f-]+', r'attention required.*cloudflare'],
            'block_codes': [403, 503, 520, 521, 522, 523, 524, 525]
        },
        'akamai': {
            'headers': ['x-akamai-request-id', 'akamai-origin-hop', 'x-akamai-session-info'],
            'server_patterns': [r'akamaighost', r'akamai'],
            'body_patterns': [r'reference\s*#[\d\.]+', r'akamai'],
            'block_codes': [403, 503]
        },
        'aws_waf': {
            'headers': ['x-amzn-requestid', 'x-amz-cf-id', 'x-amzn-trace-id'],
            'server_patterns': [r'cloudfront', r'awselb'],
            'body_patterns': [r'request blocked', r'aws waf', r'access denied'],
            'block_codes': [403, 503]
        },
        'imperva': {
            'headers': ['x-cdn', 'x-iinfo', 'x-cdn-forward'],
            'server_patterns': [r'incapsula', r'imperva'],
            'body_patterns': [r'incapsula', r'visid_incap', r'_incap_', r'imperva'],
            'block_codes': [403, 503]
        },
        'f5_bigip': {
            'headers': ['x-cnection', 'x-wa-info'],
            'server_patterns': [r'bigip', r'f5', r'big-?ip'],
            'body_patterns': [r'the requested url was rejected', r'security policies', r'support id'],
            'block_codes': [403, 503]
        },
        'modsecurity': {
            'headers': ['x-modsecurity'],
            'server_patterns': [r'mod_security', r'modsec'],
            'body_patterns': [r'mod_security', r'not acceptable', r'406 not acceptable', r'modsecurity'],
            'block_codes': [403, 406, 503]
        },
        'sucuri': {
            'headers': ['x-sucuri-id', 'x-sucuri-cache', 'x-sucuri-block'],
            'server_patterns': [r'sucuri'],
            'body_patterns': [r'sucuri', r'access denied - sucuri', r'cloudproxy'],
            'block_codes': [403, 503]
        },
        'wordfence': {
            'headers': ['x-wordfence'],
            'server_patterns': [],
            'body_patterns': [r'generated by wordfence', r'your access to this service has been limited', r'wordfence'],
            'block_codes': [403, 503]
        },
        'barracuda': {
            'headers': ['x-barracuda'],
            'server_patterns': [r'barracuda'],
            'body_patterns': [r'barracuda', r'access denied.*barracuda'],
            'block_codes': [403, 503]
        },
        'fortiweb': {
            'headers': ['x-fw'],
            'server_patterns': [r'fortinet', r'fortiweb'],
            'body_patterns': [r'fortinet', r'fortiweb', r'request rejected'],
            'block_codes': [403, 503]
        },
        'azure_waf': {
            'headers': ['x-azure-ref', 'x-ms-request-id'],
            'server_patterns': [r'azure', r'microsoft'],
            'body_patterns': [r'azure', r'microsoft.*blocked'],
            'block_codes': [403, 503]
        },
        'citrix_netscaler': {
            'headers': ['ns_af', 'citrix'],
            'server_patterns': [r'netscaler', r'citrix'],
            'body_patterns': [r'netscaler', r'citrix.*denied'],
            'block_codes': [403, 503]
        },
        'wallarm': {
            'headers': ['x-wallarm'],
            'server_patterns': [r'wallarm'],
            'body_patterns': [r'wallarm', r'request blocked by wallarm'],
            'block_codes': [403, 503]
        },
        'reblaze': {
            'headers': ['x-reblaze'],
            'server_patterns': [r'reblaze'],
            'body_patterns': [r'reblaze', r'access denied.*reblaze'],
            'block_codes': [403, 503]
        },
        'radware': {
            'headers': ['x-radware'],
            'server_patterns': [r'radware', r'appwall'],
            'body_patterns': [r'radware', r'unauthorized request'],
            'block_codes': [403, 503]
        }
    }

    BLOCK_STATUS_CODES = [400, 401, 403, 406, 418, 419, 429, 499, 503, 520, 521, 522, 523, 524, 525]

    def detect_waf_response(self, signature: ResponseSignature) -> bool:
        """Simple WAF detection for single response (used by engine)"""
        detected, _, _ = self.detect_waf(signature)
        return detected

    def detect_waf(self, signature: ResponseSignature) -> Tuple[bool, float, Optional[str]]:
        """
        Detect WAF presence with vendor identification
        Returns: (detected, confidence, vendor_name)
        """
        best_waf = None
        best_confidence = 0.0

        # Check each WAF signature
        for waf_name, sigs in self.WAF_SIGNATURES.items():
            confidence = self._check_waf_signature(signature, sigs)
            if confidence > best_confidence:
                best_confidence = confidence
                best_waf = waf_name

        # Base detection on block status codes
        if signature.status_code in self.BLOCK_STATUS_CODES:
            best_confidence = max(best_confidence, 0.3)

        detected = best_confidence > 0.4
        return detected, best_confidence, best_waf if detected else None

    def _check_waf_signature(self, signature: ResponseSignature, sigs: Dict) -> float:
        """Check if signature matches a specific WAF with weighted scoring"""
        confidence = 0.0
        max_score = 1.0

        # Check headers (high confidence)
        header_match_weight = 0.5
        headers_found = 0
        for header in sigs.get('headers', []):
            if any(header.lower() in k.lower() for k in signature.headers.keys()):
                headers_found += 1

        if headers_found > 0:
            confidence += header_match_weight * min(headers_found * 0.3, 1.0)

        # Check server header (medium confidence)
        server_weight = 0.3
        server = signature.server_header or ''
        for pattern in sigs.get('server_patterns', []):
            try:
                if re.search(pattern, server, re.IGNORECASE):
                    confidence += server_weight
                    break
            except Exception:
                continue

        # Check block status codes (low confidence, but indicator)
        if signature.status_code in sigs.get('block_codes', []):
            confidence += 0.2

        return min(confidence, max_score)

    def fingerprint_waf(self, results: List[TestResult]) -> Optional[str]:
        """
        Create WAF fingerprint from multiple test results (simplified for engine)
        Returns likely vendor name or None
        """
        if not results:
            return None

        waf_votes = defaultdict(int)

        for result in results:
            detected, confidence, vendor = self.detect_waf(result.response_signature)
            if detected and vendor and confidence > 0.5:
                waf_votes[vendor] += 1

        if not waf_votes:
            return None

        # Return most voted vendor
        likely_waf = max(waf_votes.items(), key=lambda x: x[1])[0]
        return likely_waf

    def fingerprint_waf_detailed(self, results: List[TestResult]) -> Dict[str, Any]:
        """
        Create comprehensive WAF fingerprint from multiple test results
        Returns detailed analysis dictionary
        """
        waf_votes = defaultdict(int)
        vendor_confidence = defaultdict(list)
        total_blocked = 0
        total_waf_detected = 0
        block_patterns = defaultdict(int)

        for result in results:
            if result.blocked:
                total_blocked += 1
                block_patterns[result.response_signature.status_code] += 1

            if result.waf_detected:
                total_waf_detected += 1

            # Detect WAF for each result
            detected, confidence, vendor = self.detect_waf(result.response_signature)
            if detected and vendor:
                waf_votes[vendor] += 1
                vendor_confidence[vendor].append(confidence)

        # Determine most likely WAF
        likely_waf = None
        likely_confidence = 0.0

        if waf_votes:
            likely_waf = max(waf_votes.items(), key=lambda x: x[1])[0]
            likely_confidence = statistics.mean(vendor_confidence[likely_waf])

        # Calculate detection rate
        detection_rate = total_waf_detected / max(len(results), 1)
        block_rate = total_blocked / max(len(results), 1)

        return {
            'detected': total_waf_detected > 0,
            'confidence': round(likely_confidence, 3),
            'likely_vendor': likely_waf,
            'vendor_votes': dict(waf_votes),
            'vendor_confidence': {k: round(statistics.mean(v), 3) for k, v in vendor_confidence.items()},
            'block_rate': round(block_rate, 3),
            'detection_rate': round(detection_rate, 3),
            'total_tests': len(results),
            'blocked_count': total_blocked,
            'block_status_distribution': dict(block_patterns),
            'assessment': self._assess_waf_strength(block_rate, detection_rate)
        }

    def _assess_waf_strength(self, block_rate: float, detection_rate: float) -> str:
        """Assess WAF enforcement strength"""
        if block_rate > 0.7 and detection_rate > 0.8:
            return "Strong enforcement - high block rate with consistent detection"
        elif block_rate > 0.4 and detection_rate > 0.5:
            return "Moderate enforcement - some inconsistencies detected"
        elif block_rate > 0.1:
            return "Weak enforcement - low block rate, potential bypass opportunities"
        else:
            return "No significant WAF enforcement detected"


class MetricsCalculator:
    """
    Advanced metrics calculation for security testing
    Implements comprehensive metrics: totals, rates, timing, and advanced coefficients
    """

    @staticmethod
    def calculate_all_metrics(results: List[TestResult]) -> TestMetrics:
        """Calculate comprehensive test metrics"""
        if not results:
            return TestMetrics()

        # Extract timing data
        response_times = [
            r.response_signature.elapsed_time * 1000  # Convert to ms
            for r in results
            if r.response_signature.elapsed_time > 0
        ]

        # Basic counts
        total_requests = len(results)
        blocked_requests = sum(1 for r in results if r.blocked)
        allowed_requests = sum(1 for r in results if not r.blocked and r.success)
        error_requests = sum(1 for r in results if r.error)

        # Status codes
        unique_status_codes = set(r.response_signature.status_code for r in results)

        # Timing statistics
        avg_response_time = statistics.mean(response_times) if response_times else 0.0
        min_response_time = min(response_times) if response_times else 0.0
        max_response_time = max(response_times) if response_times else 0.0

        # Advanced metrics
        uniformity_index = MetricsCalculator._calculate_ui(results)
        normalization_factor = MetricsCalculator._calculate_nf(results)
        mutation_potency = MetricsCalculator._calculate_mp(results)
        payload_penetration = MetricsCalculator._calculate_pp(results)
        consistency_coefficient = MetricsCalculator._calculate_cc(results)
        status_code_variance = MetricsCalculator._calculate_sc(results)

        return TestMetrics(
            total_requests=total_requests,
            blocked_requests=blocked_requests,
            allowed_requests=allowed_requests,
            error_requests=error_requests,
            unique_status_codes=unique_status_codes,
            avg_response_time=round(avg_response_time, 2),
            min_response_time=round(min_response_time, 2),
            max_response_time=round(max_response_time, 2),
            normalization_factor=normalization_factor,
            mutation_potency=mutation_potency,
            payload_penetration=payload_penetration,
            consistency_coefficient=consistency_coefficient,
            status_code_variance=status_code_variance,
            uniformity_index=uniformity_index
        )

    @staticmethod
    def _calculate_ui(results: List[TestResult]) -> float:
        """
        Uniformity Index: Consistency of behavior across URL variants
        Formula: UI = 1 - (normalized_variance_of_status_codes)
        """
        if not results:
            return 0.0

        status_codes = [r.response_signature.status_code for r in results]
        unique_statuses = set(status_codes)

        # Perfect uniformity
        if len(unique_statuses) == 1:
            return 1.0

        # Calculate variance
        if len(status_codes) <= 1:
            return 1.0

        mean_status = statistics.mean(status_codes)
        variance = statistics.variance(status_codes)

        # Normalize (max expected variance for status codes 200-599)
        max_variance = ((599 - 200) ** 2) / 4
        normalized_variance = min(variance / max_variance, 1.0)

        return round(1.0 - normalized_variance, 3)

    @staticmethod
    def _calculate_nf(results: List[TestResult]) -> float:
        """
        Normalization Fidelity: Quality of URL normalization
        Formula: NF = (equivalent_urls_treated_identically) / total_equivalent_pairs
        """
        if len(results) < 2:
            return 1.0

        # Group by base URL
        by_base = defaultdict(list)
        for r in results:
            by_base[r.variant.base_url].append(r)

        total_pairs = 0
        matching_pairs = 0

        for base_url, base_results in by_base.items():
            # Compare all pairs within same base
            for i, r1 in enumerate(base_results):
                for r2 in base_results[i + 1:]:
                    total_pairs += 1
                    # Consider equivalent if status and body hash match
                    if (r1.response_signature.status_code == r2.response_signature.status_code and
                            r1.response_signature.body_hash == r2.response_signature.body_hash):
                        matching_pairs += 1

        if total_pairs == 0:
            return 1.0

        return round(matching_pairs / total_pairs, 3)

    @staticmethod
    def _calculate_mp(results: List[TestResult]) -> float:
        """
        Mutation Potency: Consistency across HTTP methods
        Formula: MP = (methods_with_consistent_responses) / total_methods_tested
        """
        method_results = defaultdict(list)
        for r in results:
            method_results[r.request_config.method.value].append(r.response_signature.status_code)

        if len(method_results) < 2:
            return 1.0

        consistent_methods = 0
        for method, statuses in method_results.items():
            if len(set(statuses)) <= 2:  # Allow minor variation
                consistent_methods += 1

        return round(consistent_methods / len(method_results), 3)

    @staticmethod
    def _calculate_pp(results: List[TestResult]) -> float:
        """
        Payload Penetration: Success rate of payload delivery
        Formula: PP = (payloads_not_blocked) / total_payloads
        """
        payload_results = [r for r in results if r.variant.payload]

        if not payload_results:
            return 1.0

        not_blocked = sum(1 for r in payload_results if not r.blocked)
        return round(not_blocked / len(payload_results), 3)

    @staticmethod
    def _calculate_cc(results: List[TestResult]) -> float:
        """
        Consistency Coefficient: Consistency of caching behavior
        Formula: CC = (responses_with_proper_cache_headers) / total_responses
        """
        cache_consistent = 0
        for r in results:
            cache_control = r.response_signature.headers.get('cache-control', '')
            etag = r.response_signature.headers.get('etag', '')

            # Check if proper caching configured
            if cache_control or etag or r.response_signature.status_code == 304:
                cache_consistent += 1

        if not results:
            return 1.0

        return round(cache_consistent / len(results), 3)

    @staticmethod
    def _calculate_sc(results: List[TestResult]) -> float:
        """
        Status Code Variance: Variance in status codes received
        Formula: SC = normalized_variance_of_status_codes
        """
        if not results:
            return 0.0

        status_codes = [r.response_signature.status_code for r in results]

        if len(status_codes) <= 1:
            return 0.0

        variance = statistics.variance(status_codes)
        max_variance = ((599 - 200) ** 2) / 4
        normalized = min(variance / max_variance, 1.0)

        return round(normalized, 3)


class FindingsAnalyzer:
    """
    Security findings generation from test results
    Produces actionable security recommendations using core.Finding dataclass
    """

    @staticmethod
    def generate_findings(results: List[TestResult]) -> List[Finding]:
        """Generate comprehensive security findings"""
        findings: List[Finding] = []

        findings.extend(FindingsAnalyzer._find_bypass_indicators(results))
        findings.extend(FindingsAnalyzer._find_inconsistent_blocking(results))
        findings.extend(FindingsAnalyzer._find_normalization_issues(results))
        findings.extend(FindingsAnalyzer._find_method_confusion(results))
        findings.extend(FindingsAnalyzer._find_timing_anomalies(results))

        # Sort by severity
        severity_order = {
            SeverityLevel.CRITICAL: 0,
            SeverityLevel.HIGH: 1,
            SeverityLevel.MEDIUM: 2,
            SeverityLevel.LOW: 3,
            SeverityLevel.INFO: 4
        }
        findings.sort(key=lambda f: severity_order.get(f.severity, 99))

        return findings

    @staticmethod
    def _find_bypass_indicators(results: List[TestResult]) -> List[Finding]:
        """Detect potential WAF bypass vectors"""
        findings = []
        by_payload = defaultdict(lambda: {'blocked': [], 'passed': []})

        for r in results:
            if r.variant.payload:
                key = r.variant.payload.raw
                if r.blocked:
                    by_payload[key]['blocked'].append(r)
                elif 200 <= r.response_signature.status_code < 300:
                    by_payload[key]['passed'].append(r)

        for payload, groups in by_payload.items():
            if groups['blocked'] and groups['passed']:
                findings.append(Finding(
                    vulnerability_type=VulnerabilityType.UNKNOWN,
                    severity=SeverityLevel.CRITICAL,
                    title="Potential WAF Bypass Vector Detected",
                    description=f"Payload blocked in {len(groups['blocked'])} variants but allowed in {len(groups['passed'])} others",
                    payload=payload[:200],
                    response=f"Blocked in some variants, passed in others",
                    response_code=groups['passed'][0].response_signature.status_code,
                    elapsed_time=groups['passed'][0].response_signature.elapsed_time,
                    url=groups['passed'][0].url,
                    detected_waf=any(r.waf_detected for r in groups['blocked']),
                    variant_type=groups['passed'][0].variant.variant_type
                ))

        return findings

    @staticmethod
    def _find_inconsistent_blocking(results: List[TestResult]) -> List[Finding]:
        """Detect inconsistent blocking behavior"""
        findings = []
        by_payload = defaultdict(list)

        for r in results:
            if r.variant.payload:
                by_payload[r.variant.payload.raw].append(r)

        for payload, payload_results in by_payload.items():
            blocked_count = sum(1 for r in payload_results if r.blocked)
            total = len(payload_results)

            if 0 < blocked_count < total:
                findings.append(Finding(
                    vulnerability_type=VulnerabilityType.UNKNOWN,
                    severity=SeverityLevel.HIGH,
                    title="Inconsistent WAF Blocking Behavior",
                    description=f"Payload blocked in {blocked_count} of {total} URL variants",
                    payload=payload[:100],
                    response=f"{blocked_count}/{total} blocked",
                    response_code=payload_results[0].response_signature.status_code,
                    elapsed_time=payload_results[0].response_signature.elapsed_time,
                    url=payload_results[0].url,
                    detected_waf=any(r.waf_detected for r in payload_results)
                ))

        return findings

    @staticmethod
    def _find_normalization_issues(results: List[TestResult]) -> List[Finding]:
        """Detect URL normalization problems"""
        findings = []
        by_base = defaultdict(list)

        for r in results:
            by_base[r.variant.base_url].append(r)

        for base_url, base_results in by_base.items():
            status_codes = set(r.response_signature.status_code for r in base_results)

            if len(status_codes) > 3:
                findings.append(Finding(
                    vulnerability_type=VulnerabilityType.UNKNOWN,
                    severity=SeverityLevel.MEDIUM,
                    title="URL Normalization Inconsistency",
                    description=f"Base URL returns {len(status_codes)} different status codes for equivalent variants",
                    payload="N/A",
                    response=f"Status codes: {sorted(status_codes)}",
                    response_code=base_results[0].response_signature.status_code,
                    elapsed_time=base_results[0].response_signature.elapsed_time,
                    url=base_url
                ))

        return findings

    @staticmethod
    def _find_method_confusion(results: List[TestResult]) -> List[Finding]:
        """Detect HTTP method handling issues"""
        findings = []
        unsafe_methods = {HTTPMethod.PUT, HTTPMethod.DELETE, HTTPMethod.PATCH}

        unsafe_success = [
            r for r in results
            if r.request_config.method in unsafe_methods and 200 <= r.response_signature.status_code < 300
        ]

        if unsafe_success:
            findings.append(Finding(
                vulnerability_type=VulnerabilityType.UNKNOWN,
                severity=SeverityLevel.HIGH,
                title="Potentially Unsafe HTTP Methods Allowed",
                description=f"{len(unsafe_success)} potentially unsafe HTTP methods returned success",
                payload="N/A",
                response=f"Methods: {list(set(r.request_config.method.value for r in unsafe_success))}",
                response_code=unsafe_success[0].response_signature.status_code,
                elapsed_time=unsafe_success[0].response_signature.elapsed_time,
                url=unsafe_success[0].url
            ))

        return findings

    @staticmethod
    def _find_timing_anomalies(results: List[TestResult]) -> List[Finding]:
        """Detect response timing anomalies"""
        findings = []
        timings = [r.response_signature.elapsed_time * 1000 for r in results if r.response_signature.elapsed_time > 0]

        if len(timings) > 5:
            mean_time = statistics.mean(timings)
            outliers = [r for r in results if r.response_signature.elapsed_time * 1000 > mean_time * 5]

            if outliers:
                findings.append(Finding(
                    vulnerability_type=VulnerabilityType.UNKNOWN,
                    severity=SeverityLevel.LOW,
                    title="Response Timing Anomalies Detected",
                    description=f"{len(outliers)} responses significantly slower than average",
                    payload="N/A",
                    response=f"Avg: {mean_time:.2f}ms, Outliers: {len(outliers)}",
                    response_code=outliers[0].response_signature.status_code,
                    elapsed_time=outliers[0].response_signature.elapsed_time,
                    url=outliers[0].url
                ))

        return findings


__all__ = ['WAFDetector', 'MetricsCalculator', 'FindingsAnalyzer']
